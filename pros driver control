#include "main.h"

//Motor section begins
Motor intake = 2_mtr;
Motor puncher = 1_mtr;
Motor angler = 4_mtr;
Motor scraper = 6_rmtr;
intake.setGearing(AbstractMotor::gearset::blue);
angler.setGearing(AbstractMotor::gearset::blue);
//Motor section ends
//Section sensor begins
pros::ADILineSensor intakeSense('G');
pros::ADILineSensor puncherSense('F');
ADIButton puncherSwitch('B');
//Button section begins
ControllerButton intakeInButton(ControllerDigital::L2);
ControllerButton puncherDoubleButton(ControllerDigital::L1);
ControllerButton puncherUp(ControllerDigital::R1);
ControllerButton puncherDown(ControllerDigital::R2);
ControllerButton intakeOutButton(ControllerDigital::B);
ControllerButton xToDoubt(ControllerDigital::X);


//globals
bool ballIntake, ballPuncher;
const int intakeThresh = 60;
const int puncherThresh = 60;
//end globals

//tasks
void puncherSensors() {
   while(1) {
           if(puncherSense.get_value() > puncherThresh) //if is no ball in launcher
           {
               if (intakeSense.get_value() > intakeThresh) //if is no ball in intake
               {
                   ballIntake = false;
                   ballPuncher = false;
               }
               else
               {
                   ballIntake = true;
                   ballPuncher = false;
               }
           }
           else //is ball in intake
           {
               if(intakeSense.get_value() > intakeThresh) //if is no ball in intake
               {
                   ballIntake = false;
                   ballPuncher = true;
               }
               else //if is no ball in intake
               {
                   ballIntake = true;
                   ballPuncher = true;
               }
           }
pros::delay(20);
    }
}



void intakeWatchdog() {
   while(1) {
   if(ballIntake == true && ballPuncher == true)
   {
       intake.move_velocity(0);
   }
   else
   {
       intake.move_velocity(150);
   }
       pros::delay(20);
    }
}
/**
 * Runs the operator control code. This function will be started in its own task
 * with the default priority and stack size whenever the robot is enabled via
 * the Field Management System or the VEX Competition Switch in the operator
 * control mode.
 *
 * If no competition control is connected, this function will run immediately
 * following initialize().
 *
 * If the robot is disabled or communications is lost, the
 * operator control task will be stopped. Re-enabling the robot will restart the
 * task, not resume it from where it left off.
 */

 auto drive = ChassisControllerFactory::create(
   {9, 10}, {7, 8},
   AbstractMotor::gearset::green,
   {4.125_in, 13.75_in}
 );


void opcontrol() {
	Controller controller;
  bool rollBack = false;
  angler.tarePosition();
while(true)
{

	drive.arcade((controller.getAnalog(ControllerAnalog::rightX)*1),
  controller.getAnalog(ControllerAnalog::leftY));

  if (intakeInButton.isPressed()) {
              //Intake.setStopping(vex::brakeType::hold);
              if(ballIntake == true && ballPuncher == true)
              {
                  rollBack = true;
                  intake.moveVelocity(0);
              }
              else
              {
                  while(rollBack == true)
                  {
                      intake.moveRelative(200, -50);
                      rollBack = false;
                      pros::delay(20);
                  }
                  intake.moveVelocity(200);
              }
          }
          else if(intakeOutButton.isPressed())
           {
             intake.moveVelocity(-88);
           }
           else
           {
               intake.moveVelocity(0);
           }
  if(puncherUp.isPressed())
          {
            //angler.moveVoltage(-200);

      if(angler.getPosition() < 299)
          {
              angler.moveAbsolute(590, 600);
              puncher.moveRelative(175, -200);
          }
      else
              {
                  puncher.moveRelative(200, 200);
              }
          }
   else if(puncherDown.isPressed())
          {
          //  angler.moveVelocity(200);

        if(angler.getPosition() > 300)
          {
              angler.moveAbsolute(0, 600);
              puncher.moveRelative(175, -200);
          }
        else
              {
                  //Puncher.spin(vex::directionType::fwd,200,vex::velocityUnits::pct);
                  angler.moveVelocity(0);
              }
          }
          if(puncherDoubleButton.isPressed())
     {
            /*LeftFront.setStopping(vex::brakeType::hold);
            LeftBack.setStopping(vex::brakeType::hold);
            RightFront.setStopping(vex::brakeType::hold);
            RightBack.setStopping(vex::brakeType::hold);*/
        puncher.moveRelative(175, -200);
        intake.moveVelocity(200);
        puncher.moveVelocity(-200);
        if(angler.getPosition() < 299 && puncherDoubleButton.isPressed())
          {
            angler.moveAbsolute(590, 600);
          }
          else if(angler.getPosition() > 300 && puncherDoubleButton.isPressed())
          {
             angler.moveAbsolute(0, 600);
          }
              pros::delay(500);
              puncher.moveVelocity(0);
     }
     else if(puncherSwitch.isPressed())
     {
         puncher.moveVelocity(0);
     }
        else
      {
      puncher.moveVelocity(-200);
      }

pros::Task::delay(10);
	}
}
